## SCRABBLE HELPER 
# Source code written in CoffeeScript. HTML comments generated by Docco

# ----------------------------------------------------------------------------
#  LICENCE WTFPL
#  <thomas.bonset@gmail.com> wrote this file. As long as you retain this notice you
#  can do whatever you want with it. 
# ---------------------------------------------------------------------------

# Table containing last letters placed. Will contain 'LetterinTheMatrix' objects
@newLetters=[]

# Class representing a Scrabble tile and its place on the board 
class LetterinTheMatrix
	constructor: (@value, @i, @j) ->
	equals: (letter) ->
		return (letter.value == @value and letter.i == @i and letter.j == @j)

# Map of the letter values 
# French version of Scrabble		
@map = 
	A:1 
	B:3
	C:3
	D:2
	E:1
	F:4
	G:2
	H:4 
	I:1
	J:8
	K:10
	L:1
	M:2
	N:1 
	O:1
	P:3
	Q:8
	R:1
	S:1
	T:1
	U:1 
	V:4
	W:10
	X:10
	Y:10
	Z:10

# That's the Table of Tables representing the Scrabble board 
# Size : 14*14. Will contain characters
@matrix=[]
for i in[0..14]
	matrix[i]= []
	for j in[0..14]
		matrix[i][j]=-1

# That is the Table of Tables representing the Scrabble board 
# Size : 14*14. Will contain characters
@matrixTemp=[]
for i in[0..14]
	matrixTemp[i]= []
	for j in[0..14]
		matrixTemp[i][j]=-1

@matrixJokerMask=[]
for i in[0..14]
	matrixJokerMask[i]= []
	for j in[0..14]
		matrixJokerMask[i][j]=false

		
copyMatrix = (matrixFrom, matrixTo) ->
	for i in[0..14]
		for j in[0..14]
			matrixTo[i][j]=matrixFrom[i][j]
		
		
### 
checks if word exists and is allowed in french Scrabble
###
# All words are put in a mongolab database
@checkValidity = (wordToCheck) ->
	query = {
		"first": wordToCheck.charAt(0),
		"size": wordToCheck.length
		}	
	dburl = "https://api.mongolab.com/api/1/databases/scrabbledictionnary/collections/dico1?q=" + JSON.stringify(query) + "&apiKey=V9D6fvKO2yJET9xi2bqLb798CCDTNc8G"
	req = new XMLHttpRequest()
	req.open('GET', dburl, true)
	req.send(null)	
	req.addEventListener 'readystatechange', ->
		if req.readyState is 4         
			successResultCodes = [200, 304]
			if req.status in successResultCodes	
				result = JSON.parse(req.responseText)
				if _.contains(result[0].words,wordToCheck)
					return true
			else
				console.log 'Error loading data...'
	return false
	
### 
	Function called from HTML button	
###	
@compute = () ->
	copyMatrix(matrix,matrixTemp)
	@newLetters = [] # reinitialize newLetters tab
	for i in [0..14] # parse the board and detect new letters
		for j in [0..14]
			letterTile = document.querySelector("#coord-#{i}-#{j} > div > strong")
			jokerTile = document.querySelector("#coord-#{i}-#{j} > div > input")
			if letterTile != null 
				if  matrixTemp[i][j] is -1
					newLetters.push new LetterinTheMatrix(letterTile.innerHTML, i, j)
					matrixTemp[i][j] = letterTile.innerHTML
			if jokerTile != null 
				if  matrixTemp[i][j] is -1
					newLetters.push new LetterinTheMatrix(jokerTile.value, i, j)
					matrixJokerMask[i][j] = true
					matrixTemp[i][j] = jokerTile.value	
	onGoingContent = ""
	switch detectIfNewWordIsHorizontalOrVertical() 
		when "horizontal"
			mainWord = getHorizontalWord(newLetters[0])
		#	if not checkValidity(mainWord)
		#		alert "toto"
			onGoingContent += "Horizontal : #{countWord mainWord} <br>"
			for letter in newLetters
				smallWord = getVerticalWord(letter)
				if smallWord != null
					onGoingContent += "Vertical : #{countWord smallWord} <br>"
			copyMatrix(matrixTemp,matrix)		
		when "vertical"
			mainWord = getVerticalWord(newLetters[0])
			onGoingContent += "Vertical : #{countWord mainWord} <br>"	
			for letter in newLetters
				if getHorizontalWord(letter) != null
					smallWord = getHorizontalWord(letter)
					onGoingContent += "Horizontal : #{countWord smallWord} <br>"	
			copyMatrix(matrixTemp,matrix)
		when "onlyOneLetter"
			hWord = getHorizontalWord(newLetters[0])
			vWord = getVerticalWord(newLetters[0])
			if hWord == null and vWord == null
				onGoingContent = "This tile is alone !!!"	
			else
				if hWord != null
					onGoingContent += "Horizontal : #{countWord hWord} <br>"
				if vWord != null
					onGoingContent += "Vertical : #{countWord vWord} <br>"	
				copyMatrix(matrixTemp,matrix)
		when "unknown"
			onGoingContent = "unknown, please replace your tiles"			
	document.getElementById("onGoing").innerHTML=onGoingContent

### 
gets how much points the new word remains
###
countWord = (listofLetters) ->
	result = ""
	score = 0
	for letter in listofLetters
		temp = letter.value
		result += temp
		if matrixJokerMask[letter.i][letter.j]
			valueOfLetter=0	
		else 


			valueOfLetter=map[temp]
		for newletter in newLetters
			if letter.equals(newletter)
				switch document.getElementById("coord-#{letter.i}-#{letter.j}").className		
					when "blue-pane"
						valueOfLetter = valueOfLetter*3
					when "cyan-pane"
						valueOfLetter = valueOfLetter*2
	


		score += valueOfLetter
	return "#{result} : #{score} * #{getWordMultipliers(listofLetters)} = #{score*getWordMultipliers(listofLetters)}" 

###
 multiplies the points by multiplier pans
###
getWordMultipliers= (listofLetters) ->
	multiplier = 1
	for letter in listofLetters
		for newletter in newLetters
			if letter.equals(newletter)
				switch document.getElementById("coord-#{letter.i}-#{letter.j}").className		
					when "pink-pane"
						multiplier *=2
					when "red-pane"
						multiplier *=3
	return multiplier
	
###
 get the word by checking left and right panes
### 
getHorizontalWord = (letter) ->
	result=[]
	cursor = letter.j
	while matrixTemp[letter.i][cursor] != -1 and cursor != 0
		cursor--
	if matrixTemp[letter.i][cursor] == -1 then cursor++	
	while matrixTemp[letter.i][cursor] != -1
		result.push new LetterinTheMatrix(matrixTemp[letter.i][cursor],letter.i,cursor)
		cursor++
		if cursor == 15 then break
	if result.length > 1
		return result	
	else 
		return null

### 
get the word by checking up and down panes
###
getVerticalWord = (letter) ->
	result=[]
	cursor = letter.i
	while matrixTemp[cursor][letter.j] != -1 and cursor != 0
		cursor--
	if matrixTemp[cursor][letter.j] == -1 then cursor++	
	while matrixTemp[cursor][letter.j] != -1
		result.push new LetterinTheMatrix(matrixTemp[cursor][letter.j],cursor,letter.j)
		cursor++
		if cursor == 15 then break
	if result.length > 1
		return result		
	else 
		return null		
		
### 
detects if the new placed word is horizontal or vertical
###
# In a Scrabble turn, it's forbidden to place more than one aligned letters word.  
detectIfNewWordIsHorizontalOrVertical = () ->
	if newLetters.length == 1
		return "onlyOneLetter"
	coordList=[]
	for letterinTheMatrix in newLetters
	    coordList.push letterinTheMatrix.i
	if (coordList.every (x)-> x==coordList[0])
		return "horizontal"
	coordList=[]
	for letterinTheMatrix in newLetters
	    coordList.push letterinTheMatrix.j
	if (coordList.every (x)-> x==coordList[0])
		return "vertical"
	return "unknown"

### 
Drag & drop functions. 
### 
# Helpful for moving tiles	
@drag = (target, event) ->
	event.dataTransfer.setData "tile", target.id
	
@drop = (target, event) ->
	id = event.dataTransfer.getData "tile"
	target.appendChild document.getElementById(id)
	event.preventDefault() 
	