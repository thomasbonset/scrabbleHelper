## SCRABBLE HELPER 
# Source code written in CoffeeScript. HTML comments generated by Docco

###  LICENCE WTFPL ###
#     <thomas (dot) bonset (at) gmail.com> wrote this file. As long as you retain this notice you can do whatever you want with it. 

# Table containing last letters placed. Will contain 'LetterinTheMatrix' objects
@newLetters=[]

@roots = (0 for [1..225])

# Class representing a Scrabble tile and its place on the board 
class LetterinTheMatrix
	constructor: (@value, @i, @j) ->
	equals: (letter) ->
		return (letter.value == @value and letter.i == @i and letter.j == @j)

# Map of the letter values 
# French version of Scrabble		
@map = 
	A:1 
	B:3
	C:3
	D:2
	E:1
	F:4
	G:2
	H:4 
	I:1
	J:8
	K:10
	L:1
	M:2
	N:1 
	O:1
	P:3
	Q:8
	R:1
	S:1
	T:1
	U:1 
	V:4
	W:10
	X:10
	Y:10
	Z:10

# That's the Table of Tables representing the Scrabble board 
# Size : 14*14. Will contain characters
@matrix=[]
for i in[0..14]
	matrix[i]= []
	for j in[0..14]
		matrix[i][j]=-1

# That is the Table of Tables representing the Scrabble board 
# Size : 14*14. Will contain characters
@matrixTemp=[]
for i in[0..14]
	matrixTemp[i]= []
	for j in[0..14]
		matrixTemp[i][j]=-1

@matrixJokerMask=[]
for i in[0..14]
	matrixJokerMask[i]= []
	for j in[0..14]
		matrixJokerMask[i][j]=false

		
copyMatrix = (matrixFrom, matrixTo) ->
	for i in[0..14]
		for j in[0..14]
			matrixTo[i][j]=matrixFrom[i][j]
		
		
#### checks if word exists and is allowed in french Scrabble 
# All words are put in a mongolab database
@checkValidity = (wordToCheck) ->
	query = {
		"first": wordToCheck.charAt(0),
		"size": wordToCheck.length
		}	
	dburl = "https://api.mongolab.com/api/1/databases/scrabbledictionnary/collections/dico1?q=" + JSON.stringify(query) + "&apiKey=V9D6fvKO2yJET9xi2bqLb798CCDTNc8G"
	req = new XMLHttpRequest()
	req.open('GET', dburl, false)
	req.send(null)	
	if req.status is 200 or req.status is 304 
		result = JSON.parse(req.responseText)
		if _.contains(result[0].words,wordToCheck)
			return true
		else
			console.log 'Error loading data...'
	return false
	
#### Function called from HTML button	
@compute = () ->
	copyMatrix(matrix,matrixTemp)
	@newLetters = [] # reinitialize newLetters tab
	for i in [0..14] # parse the board and detect new letters
		for j in [0..14]
			letterTile = document.querySelector("#coord-#{i}-#{j} > div > strong")
			jokerTile = document.querySelector("#coord-#{i}-#{j} > div > input")
			if letterTile != null 
				if  matrixTemp[i][j] is -1
					newLetters.push new LetterinTheMatrix(letterTile.innerHTML, i, j)
					matrixTemp[i][j] = letterTile.innerHTML
			if jokerTile != null 
				if  matrixTemp[i][j] is -1
					newLetters.push new LetterinTheMatrix(jokerTile.value, i, j)
					matrixJokerMask[i][j] = true
					matrixTemp[i][j] = jokerTile.value	
	validateTurn = true
	onGoingContent = ""
	if matrixTemp[7][7] is -1
		validateTurn = false
		onGoingContent = "Center tile must be filled"
	else
		if countZones() > 1
			validateTurn = false
			onGoingContent = "There is an isolated word"
		else	
			switch detectIfNewWordIsHorizontalOrVertical() 
				when "horizontal"
					mainWord = getHorizontalWord(newLetters[0])
					if checkValidity(getWord mainWord)
						onGoingContent += "Horizontal : #{countWord mainWord} <br>"
						for letter in newLetters
							smallWord = getVerticalWord(letter)
							if smallWord != null
								if checkValidity(getWord smallWord)
									onGoingContent += "Vertical : #{countWord smallWord} <br>"
								else
									validateTurn = false
									onGoingContent	= "#{getWord smallWord} does not exist"
					else 
						validateTurn = false
						onGoingContent	= "#{getWord mainWord} does not exist"
				when "vertical"
					mainWord = getVerticalWord(newLetters[0])
					if checkValidity(getWord mainWord)
						onGoingContent += "Vertical : #{countWord mainWord} <br>"	
						for letter in newLetters
							smallWord = getHorizontalWord(letter)
							if smallWord != null
								if checkValidity(getWord smallWord)
									onGoingContent += "Horizontal : #{countWord smallWord} <br>"
								else
									validateTurn = false
									onGoingContent	= "#{getWord smallWord} does not exist"	
					else 
						validateTurn = false
						onGoingContent	= "#{getWord mainWord} does not exist"				
				when "onlyOneLetter"
					hWord = getHorizontalWord(newLetters[0])
					vWord = getVerticalWord(newLetters[0])
					if hWord == null and vWord == null
						onGoingContent = "This tile is alone !!!"
						validateTurn = false	
					else
						if hWord != null
							if checkValidity(getWord hWord)
								onGoingContent += "Horizontal : #{countWord hWord} <br>"
							else
								validateTurn = false	
								onGoingContent	= "#{getWord hWord} does not exist"		
						if vWord != null 
							if checkValidity(getWord vWord)
								onGoingContent += "Vertical : #{countWord vWord} <br>"	
							else
								validateTurn = false	
								onGoingContent	= "#{getWord vWord} does not exist"		
				when "unknown"
					validateTurn = false
					onGoingContent = "please replace your tiles"			
	endTurn(validateTurn,onGoingContent)

endTurn = (validateTurn,onGoingContent) ->
	if validateTurn
		copyMatrix(matrixTemp,matrix)
		document.getElementById("onGoing").innerHTML=onGoingContent
		freezeTilesOnMatrix()
	else
		document.getElementById("onErrorPopin").innerHTML=onGoingContent
		document.getElementById("modalCheck").checked="checked"

#### Validates current turn by passing all tiles on a "readonly" mode
freezeTilesOnMatrix = () ->
	for i in [0..14] # parse the board and detect new letters
		for j in [0..14]
			tile = document.querySelector("#coord-#{i}-#{j} > div")
			if  tile != null	
				tile.className="tile-fixed"
				tile.removeAttribute("draggable");

getWord = (listOfLetters) ->
	result = ""
	for letter in listOfLetters
		result = result.concat(letter.value)
	return result
		
#### gets how much points the new word remains
countWord = (listofLetters) ->
	result = ""
	score = 0
	for letter in listofLetters
		temp = letter.value
		result += temp
		if matrixJokerMask[letter.i][letter.j]
			valueOfLetter=0	
		else 
			valueOfLetter=map[temp]
		for newletter in newLetters
			if letter.equals(newletter)
				switch document.getElementById("coord-#{letter.i}-#{letter.j}").className		
					when "blue-pane"
						valueOfLetter = valueOfLetter*3
					when "cyan-pane"
						valueOfLetter = valueOfLetter*2
		score += valueOfLetter
	return "#{result} : #{score} * #{getWordMultipliers(listofLetters)} = #{score*getWordMultipliers(listofLetters)}" 

#### multiplies the points by multiplier pans
getWordMultipliers= (listofLetters) ->
	multiplier = 1
	for letter in listofLetters
		for newletter in newLetters
			if letter.equals(newletter)
				switch document.getElementById("coord-#{letter.i}-#{letter.j}").className		
					when "pink-pane"
						multiplier *=2
					when "red-pane"
						multiplier *=3
	return multiplier
	
#### Get the word by checking left and right panes
getHorizontalWord = (letter) ->
	result=[]
	cursor = letter.j
	while matrixTemp[letter.i][cursor] != -1 and cursor != 0
		cursor--
	if matrixTemp[letter.i][cursor] == -1 then cursor++	
	while matrixTemp[letter.i][cursor] != -1
		result.push new LetterinTheMatrix(matrixTemp[letter.i][cursor],letter.i,cursor)
		cursor++
		if cursor == 15 then break
	if result.length > 1
		return result	
	else 
		return null

#### Get the word by checking up and down panes
getVerticalWord = (letter) ->
	result=[]
	cursor = letter.i
	while matrixTemp[cursor][letter.j] != -1 and cursor != 0
		cursor--
	if matrixTemp[cursor][letter.j] == -1 then cursor++	
	while matrixTemp[cursor][letter.j] != -1
		result.push new LetterinTheMatrix(matrixTemp[cursor][letter.j],cursor,letter.j)
		cursor++
		if cursor == 15 then break
	if result.length > 1
		return result		
	else 
		return null		
		
#### Detects if the new placed word is horizontal or vertical
# In a Scrabble turn, it's forbidden to place more than one aligned letters word.  
detectIfNewWordIsHorizontalOrVertical = () ->
	if newLetters.length == 1
		return "onlyOneLetter"
	coordList=[]
	for letterinTheMatrix in newLetters
	    coordList.push letterinTheMatrix.i
	if (coordList.every (x)-> x==coordList[0])
		return "horizontal"
	coordList=[]
	for letterinTheMatrix in newLetters
	    coordList.push letterinTheMatrix.j
	if (coordList.every (x)-> x==coordList[0])
		return "vertical"
	return "unknown"

countZones = () ->
	@roots = (0 for [1..225])
	pos = 0
	for j in [0..14] 
		for i in [0..14]
			pos++
			if matrixTemp[i][j] isnt -1
				root = -1
				if (i>0) and matrixTemp[i-1][j] isnt -1 then root = union(find(pos-1), root)
				if (j>0) and matrixTemp[i][j-1] isnt -1 then root = union(find(pos-15), root)
				if root == -1 then roots[pos]=pos else roots[pos]=root
	for index in [0..225]
		roots[index] = find(index);
	return _.size _.uniq _.compact roots
	
find = (pos) ->
	while (roots[pos] != pos) 
		pos=roots[pos]
	return pos
	
union = (r1, r2) ->
	if r1 == r2
		return r1
	if r1 == -1 
		return r2
	if r2 == -1 
		return r1
	if r1 < r2
		roots[r2] = r1
		return r1
	else
		roots[r1] = r2
		return r2	


	
	
#### Drag & drop functions. 
# Helpful for moving tiles	
@drag = (target, event) ->
	event.dataTransfer.setData "tile", target.id
	
@drop = (target, event) ->
	id = event.dataTransfer.getData "tile"
	target.appendChild document.getElementById(id)
	event.preventDefault() 
	
